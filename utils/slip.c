/** 
 * @file 	slip.c
 * @author 	Mohit Rathod
 * Created: 17 07 2024, 07:54:54 pm
 * -----
 * Last Modified: 18 07 2024, 07:09:25 am
 * Modified By  : Mohit Rathod
 * -----
 * MIT License
 * https://opensource.org/licenses/MIT
 * @brief   Serial Line IP implementation per RFC1055
 * 
 */

#include <utils/slip.h>
#include <dev/serial.h>

/**
 * @brief SEND_PACKET: sends a packet of length "len", 
 *        starting at location "p".
 * @param[in] p - pointer to packet
 * @param[in] len - length of packet
 * @return None
 */
void slip_send_packet(uchar_t *p, int8_t len)
{
	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	serial_putchar(SLIP_END);

	/* for each byte in the packet, send the appropriate character
	 * sequence
	 */
	while(len--)
    {
		switch(*p)
        {
		    /*  if it's the same code as an END character, we send a
            *   special two character code so as not to make the
            *   receiver think we sent an END
            */
            case SLIP_END:
                serial_putchar(SLIP_ESC);
                serial_putchar(SLIP_ESC_END);
                break;

            /*  if it's the same code as an ESC character,
            *   we send a special two character code so as not
            *   to make the receiver think we sent an ESC
            */
            case SLIP_ESC:
                serial_putchar(SLIP_ESC);
                serial_putchar(SLIP_ESC_ESC);
                break;
            /* otherwise, we just send the character
            */
            default:
                serial_putchar(*p);
		}
		p++;
	}

	/* tell the receiver that we're done sending the packet
	 */
	serial_putchar(SLIP_END);
	serial_putchar(SLIP_END);
}

/**
 * @brief RECV_PACKET: reads a packet from UART buffer into
 *        the buffer located at "p".If more than len bytes 
 *        are received, the packet will be truncated.
 * @param[out] p - pointer to packet buffer with copied data.
 * @param[in] len - length of packet buffer
 * @param[out] status - current packet status via pointer 
 * 
 * @return  Number of bytes stored in the buffer.
 */
int8_t slip_recv_packet(uchar_t *p, int8_t len, pkt_status_t *status)
{
	uchar_t c;
	int8_t received = 0;

	/*  sit in a loop reading bytes until we put together
	 *  a whole packet.Make sure not to copy them into 
     *  the packet if we run out of room.
	 */
	while(1)
    {
	    /*  Ensure the UART receive buffer has atleast two bytes
         * of data in it(for the ESC encoding case).
         * If not, return and run in next call.  
		 */
        if( getSerialCount() < 2 )
        {
            *status = PENDING;
            return received;
        }
        /* get a character to process */
        serial_getchar(&c);

        /* SLIP Decode */
        switch(c)
        {

            /* if it's an END character then we're done with
            * the packet
            */
            case SLIP_END:
                /* a minor optimization: if there is no
                * data in the packet, ignore it. This is
                * meant to avoid bothering App with all
                * the empty packets generated by the
                * duplicate END characters which are in
                * turn sent to try to detect line noise.
                */
                if(received)
                {
                    *status = COMPLETE;
                    return received;
                }
                else {
                    break;
                }

                /* if it's the same code as an ESC character, wait
                * and get another character and then figure out
                * what to store in the packet based on that.
                */
            case SLIP_ESC:
                serial_getchar(&c);

                /* if "c" is not one of these two, then we
                    * have a protocol violation.  The best bet
                    * seems to be to leave the byte alone and
                    * just stuff it into the packet
                    */
                switch(c)
                {
                    case SLIP_ESC_END:
                        c = SLIP_END;
                        break;
                    case SLIP_ESC_ESC:
                        c = SLIP_ESC;
                        break;
                }

            default:
                /* Store the character */
                if(received < len)
                {
                    p[received++] = c;
                }
        }
	}
}
